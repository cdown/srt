#!/usr/bin/env python

"""Remove subtitles by index or timestamp."""

import srt
import datetime
import srt_tools.utils
import logging

log = logging.getLogger(__name__)

def parse_args():
    examples = {
        "Remove a single caption at index 10": "srt remove -i example.srt -t 10 11",
        "Remove captions within :05 - :08": "srt remove -i example.srt -t 00:00:5,00 00:00:8,00",
        "Remove captions from index 10 to the end of the file.": "srt remove -i example.srt -t 10",
        "Remove captions from :16 to the end of the file.": "srt remove -i example.srt -t 00:00:16,00",
        "Remove captions from index 2 to the 3rd to last index:": "srt remove -i example.srt -t 2 -3",
        "Remove captions from index 5 to timestamp :17": "srt remove -i example.srt -t 5 00:00:17,00",
        "Remove captions non-sequentially": "srt remove -i example.srt -t 24 6"
    }
    parser = srt_tools.utils.basic_parser(description=__doc__, examples=examples)
    parser.add_argument(
    "--t",
    metavar=("INDEX or TIMESTAMP"),
    nargs="+",
    required=True,
    help="The index (from 0) or timestamp to start or stop removing at."
    )
    return parser.parse_args()


def get_timestamp(subs, obj):
    """Parse an object for a datetime.timedelta"""
    if isinstance(obj, datetime.timedelta):
        return obj

    try:
        idx = int(obj)
        list_subs = subs if isinstance(subs, list) else list(subs)
        len_subs = len(list_subs)
        if (idx >= 0 and idx >= len_subs) or (idx < 0 and -idx > len_subs):
            raise IndexError("There is no caption at the specified index.")
        return list_subs[idx].start
    except ValueError:
        try:
            return srt.srt_timestamp_to_timedelta(obj)
        except srt.TimestampParseError:
            raise ValueError("You must enter a whole number index or timestamp (hh:mm:ss,ms) for caption arguments.")


def binary_search(arr, n, timestamp, at=False, highest=False):
    """
    Search for the index of the caption directly after the specified timestamp.
    If 'at' is True, captions equivalent to the start can be found.
    If 'highest' is True, return the highest indexed caption in the case of duplicates
    instead of the lowest indexed duplicate.

    return -1 if no index found.
    """
    found = False
    low = 0
    high = n
    mid = 0
    while low < high:
        mid = (high + low) // 2
        if arr[mid].start < timestamp:
            low = mid + 1
        elif arr[mid].start > timestamp or (at and arr[mid].start == timestamp):
            if not found and mid > 0 and (
                    arr[mid - 1].start > timestamp or (at and arr[mid - 1].start == timestamp)):
                high = mid
            elif not found:
                found = True
            elif highest and mid + 1 < n and (arr[mid].start == arr[mid + 1].start or (at and arr[mid + 1].start == timestamp)):
                low = mid + 1
            else:
                return mid
        else:
            low = mid + 1
    return -1


def contains_timestamp(caption, timestamp):
    return caption.start <= timestamp < caption.end


def captions_containing_timestamp(subs, timestamp, sorted=False):
    """
    Find the nearest uncontained caption before and after the given timestamp.
    If sorted=True, subtitles are assumed to be sorted.

    :rtype: array
    """
    # edge cases
    subs = subs if isinstance(subs, list) else list(subs)
    len_subs = len(subs)
    if len_subs == 0:
        return []
    elif timestamp < subs[0].start:
        return []
    elif not sorted:
        subs.sort()

    # find the nearest (uncontained) caption that starts after the timestamp
    ndx = binary_search(subs, len_subs, timestamp, highest=True)
    ndx = ndx if ndx != -1 else len_subs

    # find captions that contain the timestamp
    captions = []
    for i in range(0, ndx):
        if contains_timestamp(subs[i], timestamp):
            captions.append(subs[i])
    return captions


def split(subs, timestamp):
    """
    Splits subtitles at a given timestamp.
    :rtype: :term:`generator` of :py:class:`Subtitle` objects
    """
    subs = subs if isinstance(subs, list) else list(subs)
    captions = captions_containing_timestamp(subs, timestamp)
    for caption in captions:
        if caption.start != timestamp and caption.end != timestamp:
            subs.pop(caption.index - 1)
            subs.append(srt.Subtitle(0, caption.start, timestamp, caption.content))
            subs.append(srt.Subtitle(0, timestamp, caption.end, caption.content))
    return srt.sort_and_reindex(subs)


def remove_caption_index(subs, index_one, index_two=0):
    """
    Removes captions from subtitles by index.
    When index one > index two, captions up to index two will be removed
    and captions after index one will be removed.

    :param int index_one: The inclusive index to remove from.
    :param int index_two: The exclusive index to remove to.
    :rtype: :term:`generator` of :py:class:`Subtitle` objects
    """
    # use a deque for O(1) removal in non-sequential cases
    from collections import deque
    subs = deque(subs)
    len_subs = len(subs)

    # check bounds
    index_one_positive = index_one >= 0
    index_two_positive = index_two >= 0
    if (len_subs == 0 or (index_one_positive and index_one >= len_subs)
        or (not index_one_positive and -index_one > len_subs)
        or (index_two_positive and index_two > len_subs)
        or (not index_two_positive and -index_two > len_subs + 1)):
        raise IndexError

    # convert index to positive equivalent
    index_one = index_one % len_subs if not index_one_positive and index_one != len_subs else index_one
    index_two = index_two % len_subs if not index_two_positive and index_two != len_subs else index_two

    # remove the captions
    if index_one == index_two:
        return
    elif index_one > index_two:
        [subs.popleft() for i in range(index_two)]
        [subs.pop() for i in range(index_one, len_subs)]
        yield from srt.sort_and_reindex(subs)
        return

    for i in range(index_two - 1, index_one - 1, -1):
        del subs[i]
    yield from srt.sort_and_reindex(subs)


def remove_caption_timestamp(subs, timestamp_one, timestamp_two=datetime.timedelta()):
    """
    Removes captions from subtitles by timestamp.
    When timestamp one > timestamp two, captions up to index two will be removed
    and captions after index one will be removed.

    :param int index_one: The inclusive index to remove from.
    :param int index_two: The exclusive index to remove to.
    :rtype: :term:`generator` of :py:class:`Subtitle` objects
    """
    if timestamp_one == timestamp_two:
        return

    # Split the caption at the start and end of the block(s).
    subs = split(subs, timestamp_one)
    subs = split(subs, timestamp_two)
    subs = subs if isinstance(subs, list) else list(subs)
    len_subs = len(subs)
    if len_subs == 0:
        return

    # Determine the sequential edge case.
    sequential = timestamp_one < timestamp_two
    t2_before_first = timestamp_two <= subs[0].start
    if sequential and t2_before_first:
        yield from subs
        return

    # Determine the first bound and it's edge cases.
    cdx = binary_search(subs, len_subs, timestamp_one, at=True, highest=False)
    t1_after_last = True if cdx == -1 else False
    if (sequential and t1_after_last) or (not sequential and t2_before_first and t1_after_last):
        yield from subs
        return

    # Determine the second bound and it's edge cases.
    cdx2 = binary_search(subs, len_subs, timestamp_two, at=True, highest=False)
    t2_after_last = True if cdx2 == -1 else False
    if sequential and timestamp_one <= subs[0].start and t2_after_last:
        return
    cdx2 = cdx2 - 1 if timestamp_two < subs[cdx2].start else cdx2
    yield from remove_caption_index(subs, cdx, cdx2)


def main():
    args = parse_args()
    logging.basicConfig(level=args.log_level)
    srt_tools.utils.set_basic_args(args)

    subs = list(args.input)
    args.t[0] = get_timestamp(subs, args.t[0])
    if len(args.t) == 1:
        removed_subs = remove_caption_timestamp(subs, args.t[0])
    else:
        len_subs = len(subs)
        args.t[1] = len_subs if isinstance(args.t[1], int) and len_subs == args.t[1] else get_timestamp(subs, args.t[1])
        removed_subs = remove_caption_timestamp(subs, args.t[0], args.t[1])

    output = srt_tools.utils.compose_suggest_on_fail(removed_subs, strict=args.strict)

    try:
        args.output.write(output)
    except (UnicodeEncodeError, TypeError):  # Python 2 fallback
        args.output.write(output.encode(args.encoding))

if __name__ == "__main__":  # pragma: no cover
    main()
